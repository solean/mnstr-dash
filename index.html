<!doctype html>
<html lang="en" data-theme="light">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MNSTR EV Dashboard</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Bungee:wght@400&family=Space+Grotesk:wght@400;500;600&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="styles.css">
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.4/dist/chart.umd.min.js"></script>
  </head>
<body>
  <div class="app">
    <header>
      <h1>MNSTR Gacha Dashboard</h1>
      <p class="lede">Pull fresh pack pricing and chase card odds straight from the MNSTR API. We compute expected value, profit, and hit odds so you know how the packs pencil out right now.</p>
      <div class="actions">
        <button id="refresh">Refresh data</button>
        <button id="theme-toggle" class="ghost" type="button">Dark mode</button>
        <span class="status" id="status">Waiting to load…</span>
      </div>
    </header>

    <main id="tiers"></main>
    <div class="loader" id="loader">Loading live data…</div>
    <div class="error" id="error" hidden></div>
  </div>

  <script>
    const BASE_URL = 'https://api.mnstr.xyz';
    const PRICE_URL = `${BASE_URL}/gacha/prices`;

    const currency = new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD' });
    const percent = new Intl.NumberFormat('en-US', { maximumFractionDigits: 2 });

    const tierContainer = document.getElementById('tiers');
    const statusEl = document.getElementById('status');
    const errorEl = document.getElementById('error');
    const loaderEl = document.getElementById('loader');
    const refreshBtn = document.getElementById('refresh');
    const themeToggle = document.getElementById('theme-toggle');
    const chartRegistry = {};

    refreshBtn.addEventListener('click', () => loadData());
    themeToggle.addEventListener('click', () => {
      const current = document.documentElement.getAttribute('data-theme') || 'light';
      const next = current === 'dark' ? 'light' : 'dark';
      setTheme(next);
    });

    function setTheme(theme) {
      document.documentElement.setAttribute('data-theme', theme);
      localStorage.setItem('theme', theme);
      themeToggle.textContent = theme === 'dark' ? 'Light mode' : 'Dark mode';
    }

    const savedTheme = localStorage.getItem('theme');
    setTheme(savedTheme || 'light');

    function showError(message) {
      errorEl.textContent = message;
      errorEl.hidden = false;
    }

    function clearError() {
      errorEl.hidden = true;
      errorEl.textContent = '';
    }

    function probabilityScale(cards) {
      const rawSum = cards.reduce((sum, card) => sum + Number(card.probability), 0);
      if (Math.abs(rawSum - 1) < 1e-6) return 1;
      if (Math.abs(rawSum - 100) < 1e-2) return 0.01;
      return 1 / rawSum;
    }

    function computeMetrics(cards, priceUsd) {
      const costOfPack = Number(priceUsd);
      const scale = probabilityScale(cards);

      const expectedValue = cards.reduce((sum, card) => {
        const p = Number(card.probability) * scale;
        const value = Number(card.fmv);
        return sum + p * value;
      }, 0);

      const sorted = [...cards].sort((a, b) => Number(a.fmv) - Number(b.fmv));
      let cumulative = 0;
      let medianValue = 0;
      for (const card of sorted) {
        cumulative += Number(card.probability) * scale;
        if (cumulative >= 0.5) {
          medianValue = Number(card.fmv);
          break;
        }
      }

      const oddsOverCost = cards.reduce((sum, card) => {
        if (Number(card.fmv) >= costOfPack) {
          return sum + Number(card.probability) * scale;
        }
        return sum;
      }, 0) * 100;

      const profit = expectedValue - costOfPack;
      const evPercent = (expectedValue / costOfPack) * 100;
      const profitPercent = (profit / costOfPack) * 100;
      const medianPercent = ((medianValue - costOfPack) / costOfPack) * 100;

      return {
        expectedValue,
        medianValue,
        oddsOverCost,
        costOfPack,
        profit,
        evPercent,
        profitPercent,
        medianPercent,
        probScale: scale
      };
    }

    function buildProfitCurve(cards, priceUsd, scale) {
      const sorted = [...cards].sort((a, b) => Number(a.fmv) - Number(b.fmv));
      let tailProb = sorted.reduce((sum, card) => sum + Number(card.probability) * scale, 0);
      const points = sorted.map(card => {
        const value = Number(card.fmv);
        const profitPct = ((value - priceUsd) / priceUsd) * 100;
        const y = tailProb * 100; // cumulative probability of pulling >= this value
        tailProb -= Number(card.probability) * scale;
        return { x: value, y, profitPct };
      });
      return points;
    }

    function renderTier(tierName, tierInfo) {
      const { cards, metrics, curve } = tierInfo;
      const cardRows = cards.map(card => {
        const chance = Number(card.probability) * metrics.probScale * 100;
        const probDisplay = percent.format(chance);
        const title = card.title || card.playerName || card.cardName || 'Card';
        const setYear = [card.year, card.set].filter(Boolean).join(' · ');
        const grading = [card.gradingCompany, card.grading].filter(Boolean).join(' ');
        const metaPieces = [setYear, grading].filter(Boolean);
        const imageUrl = card.image || (Array.isArray(card.images) && card.images[0]?.url) || '';
        const preview = imageUrl ? `
          <div class="card-preview">
            <img src="${imageUrl}" alt="${title}">
          </div>
        ` : '';
        return `
          <tr class="card-row">
            <td>
              <span class="card-name">${title}</span>
              ${metaPieces.length ? `<span class="card-meta">${metaPieces.join(' • ')}</span>` : ''}
              ${preview}
            </td>
            <td class="value-cell">${currency.format(Number(card.fmv))}</td>
            <td class="prob-cell">${probDisplay}%</td>
          </tr>
        `;
      }).join('');

      const canvasId = `chart-${tierName.replace(/\\s+/g, '-').toLowerCase()}`;

      return `
        <section class="tier">
          <div class="tier-head">
            <h2>${tierName} Pack</h2>
            <div class="actions" style="margin:0;gap:8px;">
              <span class="pill price">Pack price ${currency.format(metrics.costOfPack)}</span>
              <span class="pill">${cards.length} cards</span>
            </div>
          </div>
          <div class="metrics">
            <div class="metric">
              <label>Expected Value</label>
              <div class="ev-row">
                <strong>${currency.format(metrics.expectedValue)}</strong>
                <span class="profit-chip ${metrics.profitPercent >= 0 ? '' : 'negative'}">
                  ${metrics.profitPercent >= 0 ? '+' : ''}${percent.format(metrics.profitPercent)}%
                </span>
              </div>
              <small>Pack price ${currency.format(metrics.costOfPack)}</small>
            </div>
            <div class="metric">
              <label>Median Card</label>
              <div class="ev-row">
                <strong>${currency.format(metrics.medianValue)}</strong>
                <span class="profit-chip ${metrics.medianPercent >= 0 ? '' : 'negative'}">
                  ${metrics.medianPercent >= 0 ? '+' : ''}${percent.format(metrics.medianPercent)}%
                </span>
              </div>
              <small>50% of pulls at least this value</small>
            </div>
            <div class="metric">
              <label>Profit Odds</label>
              <strong>${percent.format(metrics.oddsOverCost)}%</strong>
              <small>Chance pull ≥ pack cost</small>
            </div>
          </div>
          ${cards.length ? `
            <details class="card-toggle">
              <summary>
                <span>Show cards (${cards.length})</span>
                <span class="chevron">⌄</span>
              </summary>
              <div class="card-table">
                <table>
                  <thead>
                    <tr>
                      <th>Card</th>
                      <th>FMV</th>
                      <th>Pull %</th>
                    </tr>
                  </thead>
                  <tbody>${cardRows}</tbody>
                </table>
              </div>
            </details>
            <div class="chart-box">
              <h3>Profitability curve</h3>
              <canvas id="${canvasId}"></canvas>
            </div>
          ` : '<p class="empty">No card data available.</p>'}
        </section>
      `;
    }

    function renderCharts(tierResults) {
      // Clean up old charts
      Object.values(chartRegistry).forEach(chart => chart.destroy());

      tierResults.forEach(({ tierName, curve }) => {
        const canvasId = `chart-${tierName.replace(/\\s+/g, '-').toLowerCase()}`;
        const ctx = document.getElementById(canvasId);
        if (!ctx || !curve || !curve.length) return;

        chartRegistry[tierName] = new Chart(ctx, {
          type: 'line',
          data: {
            datasets: [{
              label: 'Odds of pulling ≥ value',
              data: curve.map(pt => ({ x: pt.x, y: pt.y })),
              borderColor: 'rgba(13, 17, 28, 0.7)',
              backgroundColor: 'rgba(246, 201, 14, 0.35)',
              fill: true,
              tension: 0.3,
              pointRadius: 3,
              pointBackgroundColor: '#f6c90e',
              pointBorderColor: '#0d111c'
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              x: {
                type: 'linear',
                title: { display: true, text: 'Card FMV ($)' },
                ticks: { color: getComputedStyle(document.documentElement).getPropertyValue('--subtext') }
              },
              y: {
                beginAtZero: true,
                title: { display: true, text: 'Probability (%)' },
                ticks: { color: getComputedStyle(document.documentElement).getPropertyValue('--subtext') }
              }
            },
            plugins: {
              legend: { display: false },
              tooltip: {
                callbacks: {
                  label: ctx => {
                    const val = currency.format(ctx.parsed.x);
                    const prob = percent.format(ctx.parsed.y);
                    return `${prob}% odds of pulling ≥ ${val}`;
                  }
                }
              },
              decimation: { enabled: false }
            }
          }
        });
      });
    }

    async function loadData() {
      loaderEl.textContent = 'Loading live data…';
      loaderEl.hidden = false;
      clearError();
      tierContainer.innerHTML = '';
      statusEl.textContent = 'Fetching current prices…';
      refreshBtn.disabled = true;

      try {
        const priceResponse = await fetch(PRICE_URL);
        if (!priceResponse.ok) throw new Error('Failed to fetch prices');
        const priceData = await priceResponse.json();
        const tiers = Object.keys(priceData.data || {});

        const tierResults = await Promise.all(tiers.map(async (tierName) => {
          const cardUrl = `${BASE_URL}/gacha/chase-cards?tier=${encodeURIComponent(tierName)}`;
          const cardRes = await fetch(cardUrl);
          if (!cardRes.ok) throw new Error(`Failed to fetch cards for ${tierName}`);
          const payload = await cardRes.json();
          const cards = payload.data || [];
          const metrics = computeMetrics(cards, priceData.data[tierName].priceUsd);
          const curve = buildProfitCurve(cards, metrics.costOfPack, metrics.probScale);
          return { tierName, cards, metrics, curve };
        }));

        tierContainer.innerHTML = tierResults
          .map(({ tierName, cards, metrics, curve }) => renderTier(tierName, { cards, metrics, curve }))
          .join('');
        renderCharts(tierResults);

        const time = new Date();
        statusEl.textContent = `Updated ${time.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}`;
      } catch (err) {
        console.error(err);
        showError(err.message || 'Unable to load data right now.');
        statusEl.textContent = 'Error loading data';
      } finally {
        loaderEl.hidden = true;
        refreshBtn.disabled = false;
      }
    }

    loadData();
  </script>
</body>
</html>
